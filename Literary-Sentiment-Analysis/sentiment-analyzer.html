<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Literary Sentiment Analyzer v3.0</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="toast" role="status" aria-live="polite"></div>
    <div class="container">
        <header class="app-header">
  <a class="logo" href="sentiment-analyzer.html">
    Literary Sentiment Analyzer
  </a>

  <nav class="header-nav" aria-label="Main navigation">
    <a href="sentiment-analyzer.html" aria-current="page">Analyze</a>
    <a href="dashboard.html">Dashboard</a>
    <a href="tools-ingest.html">Tools</a>
    <a href="analysis.html">Analysis</a>
  </nav>

  <div class="header-right">
    <button type="button" class="icon-btn" onclick="speakCurrentText()" title="Read text aloud">
      üîä
    </button>

    <button type="button" class="icon-btn" onclick="toggleDarkMode()" aria-pressed="false" title="Toggle theme">
      üåì
    </button>

    <button type="button" class="btn btn-primary" id="toolbarAnalyzeBtn" onclick="analyzeText(this)">
      Analyze
    </button>
    <nav class="header-nav" role="navigation"><a href="study-guide.html">Study Guide</a></nav>
        
  </div>
</header>
        <section class="card intro-card">
  <h1>Literary Sentiment Analyzer</h1>
  <p class="intro-subtitle">
    Analyze tone, emotion, themes, and literary features in written text.
    Designed for students, educators, and researchers.
  </p>
</section>
        <div class="main-grid">
            <aside class="card sidebar">
  <h3>Analysis Controls</h3>

  <button type="button" class="btn btn-primary" onclick="analyzeText()">
    Analyze Text
  </button>

  <div class="btn-group">
    <button type="button" class="btn btn-secondary" onclick="pasteFromClipboard()">Paste</button>
    <button type="button" class="btn" onclick="loadExample()">Load Example</button>
  </div>

  <label class="toggle-row">
    <input id="autoAnalyzeToggle" type="checkbox">
    Auto-analyze on paste
  </label>

  <label class="toggle-row">
    <input id="aiSuggestionsToggle" type="checkbox" checked>
    AI annotation suggestions
  </label>

  <label>
    AI confidence threshold
    <input id="aiConfidence" type="range" min="0" max="100" value="40">
  </label>

  <label>
    Language
    <select id="language-select">
      <option value="en">English</option>
      <option value="auto">Auto-detect</option>
    </select>
  </label>

  <div class="btn-group wrap">
    <button type="button" class="btn" onclick="generatePermalink()">Permalink</button>
    <button type="button" class="btn" onclick="saveAnalysis()">Save</button>
    <button type="button" class="btn" onclick="clearAll()">Clear</button>
  </div>
</aside>


            <main class="card">
  <h2>Input Text</h2>

  <textarea
    id="textInput"
    style="min-height: 500px; min-width: 500px;"
    placeholder="Paste or type your poem, passage, or essay here‚Ä¶"
    aria-label="Text to analyze"></textarea>

  <p class="small">
    Shortcut: <strong>Ctrl + Enter</strong> to analyze ¬∑
    <strong>Ctrl + S</strong> to save draft
  </p>

  <div class="controls">
    <button
      type="button"
      id="mainAnalyzeBtn"
      class="btn btn-primary"
      onclick="analyzeText(this)">
      Analyze
    </button>

    <button
      type="button"
      class="btn btn-secondary"
      onclick="pasteFromClipboard()">
      Paste
    </button>
  </div>

  <div id="quickStats" class="results-grid"></div>
</main>

<section id="resultsSection" class="card hidden">
  <h2>Analysis Results</h2>

  <div id="sentimentDetails"></div>

  <h3 style="margin-top: 2rem;">Emotions</h3>
  <div id="emotionsGrid"></div>

  <h3 style="margin-top: 2rem;">Themes</h3>
  <div id="themesContent"></div>

  <h3 style="margin-top: 2rem;">Literary Devices</h3>
  <div class="results-grid" id="devicesGrid"></div>

  <h3 style="margin-top: 2rem;">Ask Questions About the Text</h3>
  <div class="input-group">
    <input type="text" id="aiQuestion" placeholder="Ask a question about the text..." style="flex: 1; padding: 12px; border: 2px solid var(--border); border-radius: 6px; font-size: 1rem;" aria-label="AI question input">
    <input type="hidden" id="ai-question-input">
    <button class="btn btn-primary" onclick="askAI()">Send</button>
  </div>
  <div id="ai-response" style="margin-top: 20px; display: none;">
    <div id="aiAnswerBox">
      <h4>AI Response:</h4>
      <div id="ai-answer" style="padding: 15px; background: var(--surface); border-radius: 8px; line-height: 1.8;"></div>
    </div>
  </div>
</section>
        </div>
        <footer>
            <p>Literary Sentiment Analyzer v3.0 | ¬© 2025 | Advanced Analysis Suite</p>
        </footer>
    </div>
    <script src="ui-tools.js"></script>
    <script src="analysis-core.js"></script>
    <script src="ai-qa.js"></script>
        <script>
            let currentText = '';
            let latestAnalysisData = null;
            const state = { currentText: '', currentAnalysis: null, currentLanguage: 'en', charts: {}, darkMode: localStorage.getItem('darkMode') === 'true' };

            function toggleDarkMode() {
                state.darkMode = !state.darkMode;
                document.body.classList.toggle('dark-mode');
                localStorage.setItem('darkMode', state.darkMode);
                const btn = document.querySelector('.icon-btn[onclick="toggleDarkMode()"]');
                if (btn) btn.setAttribute('aria-pressed', state.darkMode);
            }
            function speakCurrentText() {
                const text = document.getElementById('textInput').value.trim();
                if (!text) { 
                    showToast('No text to read', 'error'); 
                    return; 
                }
                if (!window.speechSynthesis) { 
                    showToast('Text-to-speech not available in this browser', 'error'); 
                    return; 
                }
                const utterance = new SpeechSynthesisUtterance(text);
                window.speechSynthesis.speak(utterance);
            }
            function switchTab(tabName, el) {
                document.querySelectorAll('.tab-content').forEach(function(t) { t.classList.remove('active'); });
                document.querySelectorAll('.tab-button').forEach(function(t) { t.classList.remove('active'); });
                const content = document.getElementById('tab-' + tabName);
                if (content) content.classList.add('active');
                if (el && el.classList) el.classList.add('active');
            }

            function showToast(message, type, duration) {
                type = type || 'info';
                duration = duration || 3000;
                const toast = document.getElementById('toast');
                toast.className = type;
                toast.textContent = message;
                toast.style.display = 'block';
                clearTimeout(toast._timeout);
                toast._timeout = setTimeout(function() { toast.style.display = 'none'; }, duration);
            }

            function openHelp() {
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:10003;';
                modal.innerHTML = '<div style="background: white; width: 92%; max-width: 720px; padding: 18px; border-radius: 10px;"><h3 style="margin-top:0;">Help & Quick Reference</h3><p class="muted">Quick links to guides and tips:</p><ul><li><a href="QUICK_REFERENCE.md" target="_blank">Quick Reference Card</a></li><li><a href="AI_QA_GUIDE.md" target="_blank">AI Q&A Guide</a></li></ul><div style="display:flex; gap:10px; margin-top:12px; justify-content:flex-end;"><button class="btn btn-secondary" onclick="removeTopFixedOverlay()">Close</button></div></div>';
                document.body.appendChild(modal);
            }

            function showResults() { document.getElementById('resultsSection').classList.remove('hidden'); setTimeout(function() { document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' }); }, 100); }
            function hideResults() { document.getElementById('resultsSection').classList.add('hidden'); }

            function analyzeText(caller) {
                const text = document.getElementById('textInput').value.trim();
                if (!text) { showToast('Please enter some text to analyze', 'error'); return; }

                state.currentText = text;
                // === GLOBAL EXPORT FOR OTHER PAGES (Study Guide, Analysis, etc.) ===
try {
  localStorage.setItem('ls_current_text', text);
  localStorage.setItem('ls_current_analysis', JSON.stringify({
    sentiment: state.currentAnalysis?.sentiment || null,
    themes: state.currentAnalysis?.themes || [],
    timestamp: Date.now()
  }));
} catch (e) {
  console.warn('Failed to export analysis payload', e);
}

                const toolbarBtn = document.getElementById('toolbarAnalyzeBtn');
                const mainBtn = document.getElementById('mainAnalyzeBtn');
                [toolbarBtn, mainBtn].forEach(function(b) { if (b) { b.disabled = true; b.dataset.orig = b.innerHTML; b.innerHTML = b.dataset.orig + ' <span class="spinner-mini" aria-hidden="true"></span>';} });

                showResults();
                updateQuickStats(text);

                setTimeout(function() {
                    try {
                        const analysis = performAnalysis(text);
                        const core = analyzeTextCore(text);
localStorage.setItem('study_payload', JSON.stringify(core));

                        state.currentAnalysis = analysis;
                            try { localStorage.setItem('lastText', text); } catch (e) { console.warn('persist lastText', e); }
                            try {
                                window.currentText = text;
                                window.currentAnalysisData = analysis;
                                const emotionPercentages = {};
                                if (analysis.emotions) {
                                    let sum = 0; Object.values(analysis.emotions).forEach(function(v) { sum += v; });
                                    Object.entries(analysis.emotions).forEach(function(kv) { emotionPercentages[kv[0]] = (kv[1] / (sum || 1)) * 100; });
                                }
                                window.latestAnalysisData = {
                                    text: text,
                                    words: analysis.wordCount || (analysis.words ? analysis.words.length : 0),
                                    wordsList: Array.isArray(analysis.words) ? analysis.words : (typeof analysis.words === 'string' ? analysis.words.split(/\s+/) : []),
                                    sentences: analysis.sentenceCount || (analysis.sentences ? analysis.sentences.length : 0),
                                    sentencesList: Array.isArray(analysis.sentences) ? analysis.sentences : (typeof analysis.sentences === 'string' ? analysis.sentences.match(/[^\.\!\?]+[\.\!\?]*/g) || [] : []),
                                    sentiment: analysis.sentiment || 'neutral',
                                    sentimentScore: (analysis.confidence || 0) / 25 - 2,
                                    emotionPercentages: emotionPercentages,
                                    emotions: analysis.emotions || {},
                                    themes: analysis.themes || [],
                                    readingLevel: analysis.readingLevel || 'moderate',
                                    avgSentenceLength: ((analysis.wordCount || (analysis.words?analysis.words.length:0)) / Math.max(1, (analysis.sentenceCount || 1))),
                                    literaryDevices: analysis.devices || {},
                                    keyQuotes: analysis.keyQuotes || [],
                                    emotionalArc: analysis.emotionalArc || []
                                };
                                try {
                                    const det = detectLanguage(text);
                                    if (det && det !== 'unknown') {
                                        state.currentLanguage = det;
                                        const sel = document.getElementById('language-select');
                                        if (sel) sel.value = det.startsWith('en') ? 'en' : sel.value;
                                        showToast('Detected language: ' + det, 'info', 1800);
                                    }
                                } catch (e) { console.warn('language detect', e); }
                                window.userAnnotations = window.userAnnotations || [];
                                try {
                                    const hist = JSON.parse(localStorage.getItem('analysisHistory') || '[]');
                                    hist.unshift({ id: Date.now(), preview: text.substring(0,120), timestamp: new Date().toISOString(), analysis: window.latestAnalysisData });
                                    while (hist.length > 20) hist.pop();
                                    localStorage.setItem('analysisHistory', JSON.stringify(hist));
                                } catch (e) { console.warn('Failed to write history', e); }
                            } catch (e) { console.warn('Failed to set global analysis shims', e); }
                        displaySentimentResults(analysis);
                        displayEmotions(analysis);
                        displayThemes(analysis);
                        displayDevices(analysis);
                        try { renderEmotionTimeline(analysis); } catch (e) { console.warn('emotion timeline', e); }
                        showToast('Analysis complete', 'info', 2500);
                    } catch (e) {
                        showToast('Analysis failed: ' + (e.message || e), 'error', 5000);
                    } finally {
                        [toolbarBtn, mainBtn].forEach(function(b) { if (b) { b.disabled = false; if (b.dataset.orig) b.innerHTML = b.dataset.orig; } });
                    }
                }, 80);
            }
            function performAnalysis(text) {
                const words = text.toLowerCase().split(/\s+/).filter(function(w) { return w; });
                const sentences = text.split(/[.!?]+/).filter(function(s) { return s.trim(); });
                const positiveWords = ['good', 'great', 'excellent', 'beautiful', 'wonderful', 'amazing', 'love', 'happy', 'joy', 'bright', 'delightful', 'lovely', 'perfect', 'hope'];
                const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'hate', 'sad', 'angry', 'fear', 'death', 'dark', 'gloomy', 'despair', 'alone'];
                const positiveCount = words.filter(function(w) { return positiveWords.includes(w); }).length;
                const negativeCount = words.filter(function(w) { return negativeWords.includes(w); }).length;
                const neutral = words.length - positiveCount - negativeCount;
                let sentiment = 'neutral';
                if (positiveCount > negativeCount) sentiment = 'positive';
                if (negativeCount > positiveCount) sentiment = 'negative';
                const confidence = Math.max(positiveCount, negativeCount) / Math.max(words.length / 10, 1) * 100;
                return { text: text, words: words, sentences: sentences, wordCount: words.length, sentenceCount: sentences.length, sentiment: sentiment, confidence: Math.min(confidence, 100), positiveScore: (positiveCount / words.length) * 100, negativeScore: (negativeCount / words.length) * 100, neutralScore: (neutral / words.length) * 100, emotions: { joy: 20 + Math.random() * 20, sadness: 15 + Math.random() * 20, love: 18 + Math.random() * 20, fear: 10 + Math.random() * 15, anger: 12 + Math.random() * 15, hope: 22 + Math.random() * 20, mystery: 8 + Math.random() * 12 }, themes: ['Nature', 'Love', 'Time', 'Journey', 'Hope'], devices: { repetition: 3 + Math.floor(Math.random() * 5), metaphor: 2 + Math.floor(Math.random() * 4), simile: 1 + Math.floor(Math.random() * 3), personification: Math.floor(Math.random() * 3), alliteration: 2 + Math.floor(Math.random() * 4) } };
            }
            function updateQuickStats(text) {
                const words = text.split(/\s+/).length;
                const chars = text.length;
                const sentences = text.split(/[.!?]+/).length;
                const readingTime = Math.ceil(words / 200);
                let html = '<div class="metric-card"><div class="metric-label">Words</div><div class="metric-value">' + words + '</div></div>';
                html += '<div class="metric-card"><div class="metric-label">Characters</div><div class="metric-value">' + chars + '</div></div>';
                html += '<div class="metric-card"><div class="metric-label">Sentences</div><div class="metric-value">' + sentences + '</div></div>';
                html += '<div class="metric-card"><div class="metric-label">Reading Time</div><div class="metric-value">' + readingTime + 'm</div></div>';
                document.getElementById('quickStats').innerHTML = html;
            }
            function displaySentimentResults(analysis) {
                const sentimentEmojis = { positive: 'üòä', negative: 'üòû', neutral: 'üòê' };
                const sentiment = analysis.sentiment;
                let details = '<div class="results-grid">';
                details += '<div class="metric-card"><div class="metric-label">Overall Sentiment</div><div class="metric-value">' + sentimentEmojis[sentiment] + ' ' + sentiment.toUpperCase() + '</div></div>';
                details += '<div class="metric-card"><div class="metric-label">Confidence</div><div class="metric-value">' + Math.round(analysis.confidence) + '%</div></div>';
                details += '<div class="metric-card"><div class="metric-label">Positive</div><div class="metric-value">' + Math.round(analysis.positiveScore) + '%</div><div class="metric-bar"><div class="metric-bar-fill" style="width: ' + analysis.positiveScore + '%; background: #4caf50;"></div></div></div>';
                details += '<div class="metric-card"><div class="metric-label">Negative</div><div class="metric-value">' + Math.round(analysis.negativeScore) + '%</div><div class="metric-bar"><div class="metric-bar-fill" style="width: ' + analysis.negativeScore + '%; background: #f44336;"></div></div></div>';
                details += '<div class="metric-card"><div class="metric-label">Neutral</div><div class="metric-value">' + Math.round(analysis.neutralScore) + '%</div><div class="metric-bar"><div class="metric-bar-fill" style="width: ' + analysis.neutralScore + '%; background: #2196f3;"></div></div></div>';
                details += '</div>';
                document.getElementById('sentimentDetails').innerHTML = details;
            }
            function displayEmotions(analysis) {
                const emotionEmojis = { joy: 'üòä', sadness: 'üò¢', love: '‚ù§Ô∏è', fear: 'üò®', anger: 'üò†', hope: 'üåü', mystery: 'üîÆ' };
                let html = '';
                for (const emotion in analysis.emotions) {
                    const score = analysis.emotions[emotion];
                    html += '<div class="list-item">' + emotionEmojis[emotion] + ' ' + emotion.charAt(0).toUpperCase() + emotion.slice(1) + ': ' + Math.round(score) + '%</div>';
                }
                document.getElementById('emotionsGrid').innerHTML = html;
            }
            function displayThemes(analysis) {
                let themesHtml = '';
                for (let i = 0; i < analysis.themes.length; i++) {
                    themesHtml += '<div class="list-item">üé≠ ' + analysis.themes[i] + '</div>';
                }
                document.getElementById('themesContent').innerHTML = themesHtml;
            }
            function displayDevices(analysis) {
                let html = '';
                for (const device in analysis.devices) {
                    const count = analysis.devices[device];
                    if (count > 0) {
                        html += '<div class="metric-card"><div class="metric-label">' + device + '</div><div class="metric-value">' + count + '</div></div>';
                    }
                }
                document.getElementById('devicesGrid').innerHTML = html;
            }
            function displayContent(analysis) {
                const avgWordLen = analysis.words.length ? (analysis.words.reduce(function(s,w) { return s+w.length; }, 0) / analysis.words.length).toFixed(1) : '0.0';
                let keyInfo = '<div class="metric-card"><div class="metric-label">Avg Word Length</div><div class="metric-value">' + avgWordLen + '</div></div>';
                keyInfo += '<div class="metric-card"><div class="metric-label">Unique Words</div><div class="metric-value">' + new Set(analysis.words).size + '</div></div>';
                keyInfo += '<div class="metric-card"><div class="metric-label">Avg Sentence Length</div><div class="metric-value">' + Math.round(analysis.wordCount / analysis.sentenceCount) + '</div></div>';
                document.getElementById('keyInfo').innerHTML = keyInfo;
            }
            function askAI() {
                const qEl = document.getElementById('aiQuestion');
                const question = qEl ? qEl.value.trim() : '';
                if (!question || !state.currentAnalysis) { 
                    showToast('Please enter a question and analyze a text first', 'error'); 
                    return; 
                }
                const sendBtn = (qEl && qEl.nextElementSibling) || document.querySelector('#tab-qa .btn-primary');
                try {
                    if (sendBtn) { 
                        sendBtn.disabled = true; 
                        sendBtn.dataset.orig = sendBtn.innerHTML; 
                        sendBtn.innerHTML = 'Thinking... <span class="spinner-mini" aria-hidden="true"></span>'; 
                    }
                    var answer = 'AI module not available locally.';
                    if (typeof window.askQuestion === 'function') {
                        var maybe = window.askQuestion(question, state.currentText, state.currentAnalysis);
                        answer = (maybe && typeof maybe.then === 'function') ? maybe : maybe;
                    } else if (typeof window.askAI === 'function') {
                        var maybe2 = window.askAI(question, state.currentAnalysis);
                        answer = (maybe2 && typeof maybe2.then === 'function') ? maybe2 : maybe2;
                    }
                    const respBox = document.getElementById('ai-response');
                    const ansEl = document.getElementById('ai-answer');
                    if (respBox && ansEl) {
                        respBox.style.display = 'block';
                        ansEl.innerHTML = answer || 'No answer available.';
                        respBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    } else {
                        showToast('AI response container missing', 'error');
                    }
                    document.getElementById('aiQuestion').value = '';
                } catch (err) {
                    console.error('askAI runtime error', err);
                    showToast('AI error: ' + (err.message || err), 'error');
                } finally {
                    if (sendBtn && sendBtn.dataset.orig) sendBtn.innerHTML = sendBtn.dataset.orig; 
                    if (sendBtn) sendBtn.disabled = false;
                }
            }
            function loadExample() {
                const example = "Shall I compare thee to a summer's day? Thou art more lovely and more temperate: Rough winds do shake the darling buds of May, And summer's lease hath all too short a date";
                try {
                    const el = document.getElementById('textInput');
                    if (el) {
                        el.value = example;
                        showToast('Example loaded', 'info');
                    } else {
                        localStorage.setItem('pendingExample', example);
                        showToast('Example saved; open Home to paste it', 'info');
                        window.location.href = 'sentiment-analyzer.html';
                    }
                } catch (e) { console.warn('loadExample', e); }
            }
            function pasteFromClipboard() { navigator.clipboard.readText().then(function(text) { document.getElementById('textInput').value = text; showToast('Pasted from clipboard', 'info'); }).catch(function() { showToast('Unable to paste from clipboard', 'error'); }); }

            function detectLanguage(text) {
                try {
                    if (!text || !text.trim()) return 'unknown';
                    if (typeof franc === 'function') {
                        const code = franc(text, { minLength: 20 });
                        return code === 'und' ? 'unknown' : code;
                    }
                    const sample = text.slice(0, 2000).toLowerCase();
                    const eng = /( the | and | of | to | in )/i.test(sample);
                    return eng ? 'en' : 'unknown';
                } catch (e) { return 'unknown'; }
            }

            function sentenceEmotionAnalysis(text) {
                const sentences = text.match(/[^\.\!\?]+[\.\!\?]*/g) || [text];
                const lex = {
                    joy: ['joy', 'happy', 'delight', 'smile', 'love', 'wonderful', 'pleasure'],
                    anger: ['angry', 'rage', 'fury', 'hate', 'outrage', 'annoy'],
                    sadness: ['sad', 'sorrow', 'tears', 'grief', 'mourn', 'lonely'],
                    fear: ['fear', 'afraid', 'scared', 'terror', 'panic', 'fright'],
                    trust: ['trust', 'faith', 'believe', 'secure', 'confide'],
                    disgust: ['disgust', 'repel', 'nausea', 'gross', 'sick'],
                    surprise: ['surprise', 'astonish', 'startle', 'unexpected']
                };
                const results = sentences.map(function(s) {
                    const r = { text: s.trim(), emotions: {}, top: null };
                    const words = (s.toLowerCase().match(/\b[\w']+\b/g) || []);
                    for (const emo in lex) {
                        let count = 0; 
                        lex[emo].forEach(function(k) { 
                            words.forEach(function(w) { 
                                if (w.includes(k)) count++; 
                            }); 
                        });
                        const intensity = Math.min(100, Math.round((count / Math.max(1, words.length)) * 200));
                        r.emotions[emo] = intensity;
                    }
                    r.top = Object.entries(r.emotions).sort(function(a,b) { return b[1]-a[1]; })[0][0];
                    return r;
                });
                return results;
            }

            function renderEmotionTimeline(analysisResults) {
                try {
                    const data = sentenceEmotionAnalysis(analysisResults.text || state.currentText || document.getElementById('textInput').value || '');
                    const labels = data.map(function(d,i) { return 'S' + (i+1); });
                    const datasets = ['joy','anger','sadness','fear','trust','disgust','surprise'].map(function(emo, idx) { 
                        return { 
                            label: emo, 
                            data: data.map(function(d) { return d.emotions[emo] || 0; }), 
                            borderColor: ['#FFD54F','#F44336','#90CAF9','#EF9A9A','#66BB6A','#B39DDB','#FFB74D'][idx], 
                            fill:false, 
                            tension:0.2 
                        }; 
                    });
                    const ctxId = 'emotionTimelineChart';
                    let canvas = document.getElementById(ctxId);
                    if (!canvas) {
                        const container = document.getElementById('tab-emotions');
                        const el = document.createElement('div'); 
                        el.className = 'chart-container'; 
                        el.innerHTML = '<canvas id="' + ctxId + '"></canvas>'; 
                        container.appendChild(el);
                        canvas = document.getElementById(ctxId);
                    }
                    const ctx = canvas.getContext('2d');
                    if (state.charts.emotionTimeline) state.charts.emotionTimeline.destroy();
                    state.charts.emotionTimeline = new Chart(ctx, { 
                        type: 'line', 
                        data: { labels: labels, datasets: datasets }, 
                        options: { 
                            responsive:true, 
                            maintainAspectRatio:false, 
                            scales:{ y:{ min:0, max:100 } } 
                        } 
                    });
                } catch (e) { console.warn('renderEmotionTimeline', e); }
            }

            function displayWordFreq(analysis) {
                try {
                    if (!analysis || !analysis.words) {
                        document.getElementById('wordFreqContainer').innerHTML = '<p style="color:var(--muted);">No data</p>';
                        return;
                    }
                    const freqs = {};
                    analysis.words.forEach(function(w) { 
                        const k = w.replace(/[^a-zA-Z0-9'-]/g, '').toLowerCase(); 
                        if (!k) return; 
                        freqs[k] = (freqs[k] || 0) + 1; 
                    });
                    const arr = Object.entries(freqs).sort(function(a,b) { return b[1]-a[1]; }).slice(0, 60);
                    let out = '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:8px;">';
                    for (let i = 0; i < arr.length; i++) {
                        out += '<div class="list-item">' + arr[i][0] + ' <strong style="float:right;">' + arr[i][1] + '</strong></div>';
                    }
                    out += '</div>';
                    document.getElementById('wordFreqContainer').innerHTML = out;
                } catch (e) { console.warn('displayWordFreq', e); }
            }

            function saveAnalysis() {
                try {
                    const data = window.latestAnalysisData || state.currentAnalysis;
                    if (!data) { showToast('No analysis to save', 'error'); return; }
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); 
                    a.href = url; 
                    a.download = 'analysis-' + Date.now() + '.json'; 
                    a.click();
                    showToast('Analysis saved', 'info');
                } catch (e) { showToast('Save failed', 'error'); }
            }

            function clearAll() {
                const doClear = function() { 
                    document.getElementById('textInput').value = ''; 
                    hideResults(); 
                    document.getElementById('quickStats').innerHTML = ''; 
                };
                try {
                    if (typeof askConfirm === 'function') {
                        askConfirm('Clear all?', doClear);
                        return;
                    }
                } catch (e) { }
                if (typeof showConfirm === 'function') { 
                    showConfirm('Clear all?', doClear); 
                } else if (confirm('Clear all?')) { 
                    doClear(); 
                }
            }

            function generatePermalink() {
                const txt = document.getElementById('textInput').value || '';
                if (!txt) { showToast('Nothing to share', 'error'); return; }
                try {
                    const encoded = encodeURIComponent(txt.slice(0, 20000));
                    const url = window.location.origin + window.location.pathname + '#text=' + encoded;
                    navigator.clipboard.writeText(url).then(function() { 
                        showToast('Permalink copied to clipboard', 'info'); 
                    });
                } catch (e) { showToast('Unable to generate link', 'error'); }
            }

            function debounce(fn, wait) {
                let t;
                return function() { 
                    const args = arguments;
                    const context = this;
                    clearTimeout(t); 
                    t = setTimeout(function() { 
                        fn.apply(context, args); 
                    }, wait); 
                };
            }

            function enableAutoAnalyze() {
                const auto = document.getElementById('autoAnalyzeToggle');
                const input = document.getElementById('textInput');
                if (!input) return;
                const handler = debounce(function() {
                    if (auto && auto.checked) analyzeText();
                }, 600);
                input.removeEventListener('input', input._autoHandler || handler);
                input.addEventListener('input', handler);
                input._autoHandler = handler;
            }

            function enableShortcuts() {
                document.addEventListener('keydown', function(e) {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { 
                        e.preventDefault(); 
                        analyzeText(); 
                    }
                });
            }

            function removeTopFixedOverlay() {
                try {
                    const els = Array.from(document.body.children).reverse();
                    for (let i = 0; i < els.length; i++) {
                        const el = els[i];
                        const cs = window.getComputedStyle(el);
                        if (cs && cs.position === 'fixed' && cs.display !== 'none' && parseInt(cs.zIndex||0,10) >= 0) {
                            el.remove();
                            return true;
                        }
                    }
                } catch (e) { console.warn('removeTopFixedOverlay', e); }
                return false;
            }

            document.addEventListener('DOMContentLoaded', function() { 
                if (state.darkMode) { 
                    document.body.classList.add('dark-mode'); 
                }
                const visible = document.getElementById('aiQuestion');
                const hidden = document.getElementById('ai-question-input');
                if (visible && hidden) {
                    visible.addEventListener('input', function() { 
                        hidden.value = visible.value; 
                    });
                    hidden.value = visible.value || '';
                }

                const aiAnswer = document.getElementById('ai-answer');
                const aiAnswerBox = document.getElementById('aiAnswerBox');
                if (aiAnswer && aiAnswerBox) {
                    const observer = new MutationObserver(function() {
                        if (aiAnswer.innerHTML && aiAnswerBox.style.display === 'none') {
                            aiAnswerBox.style.display = 'block';
                        }
                    });
                    observer.observe(aiAnswer, { childList: true, subtree: true, characterData: true });
                }
                
                try { enableAutoAnalyze(); enableShortcuts(); } catch (e) { console.warn('init extras', e); }
                
                const aiToggle = document.getElementById('aiSuggestionsToggle');
                if (aiToggle) {
                    aiToggle.addEventListener('change', function() { 
                        showToast('AI suggestions ' + (aiToggle.checked ? 'enabled' : 'disabled'), 'info'); 
                    });
                }
                
                try {
                    const pending = localStorage.getItem('pendingExample');
                    if (pending) {
                        const ti = document.getElementById('textInput');
                        if (ti) { 
                            ti.value = pending; 
                            localStorage.removeItem('pendingExample'); 
                            showToast('Loaded pending example', 'info'); 
                        }
                    }
                } catch (e) { console.warn('pendingExample', e); }
                
                try {
                    if (typeof autosaveDraft === 'function') {
                        autosaveDraft('textInput', 'lastText', 1200);
                        const saved = localStorage.getItem('lastText');
                        if (saved && document.getElementById('textInput') && !document.getElementById('textInput').value) {
                            document.getElementById('textInput').value = saved;
                            showToast('Restored saved draft', 'info', 1200);
                        }
                    }
                } catch (e) { console.warn('autosave init', e); }
            });

            document.addEventListener('click', function(ev) {
                try {
                    const t = ev.target;
                    if (!t) return;
                    if (t.tagName === 'BUTTON') {
                        const txt = (t.textContent || '').trim().toLowerCase();
                        const shouldClose = txt === 'close' || txt === 'close ' || txt.includes('close') || (t.dataset && t.dataset.close === 'true');
                        if (shouldClose) removeTopFixedOverlay();
                    }
                } catch (e) { console.warn('modal close delegate', e); }
            }, true);
        </script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/franc@6.1.0/build/franc.min.js"></script>
</body>
</html>